Phase 5 : Fonctionnalités avancées de l’IA
[X] 5.0 Architecture du système d'IA modulable ✅ COMPLÉTÉ
notes : ✅ Implémenté avec un système de Goals modulaire (AIGoal, AIGoalManager, PatrolGoal, FollowPlayerGoal, CollectResourcesGoal). Le système permet d'ajouter facilement de nouveaux comportements avec gestion des priorités. Voir docs/AI_SYSTEM_SETUP.md pour la documentation complète.
libs : gdx-ai (libGDX AI) disponible en option pour des comportements plus complexes (Behavior Trees, State Machines). Instructions d'installation dans docs/AI_SYSTEM_SETUP.md
[X] 5.1 Pathfinding avancé pour l'IA ✅ COMPLÉTÉ
notes : ✅ Implémenté avec algorithme A* (PathNode, AdvancedPathfinder, PathfindingManager). Le système inclut un cache pour optimiser les calculs et supporte le pathfinding asynchrone via ExecutorService pour ne pas bloquer le thread principal. Le pathfinder prend en compte les obstacles, le terrain dangereux, et pénalise les mouvements verticaux.
libs : Le système natif est suffisant. gdx-ai ou Baritone peuvent être utilisés en option pour des fonctionnalités avancées. Voir docs/AI_SYSTEM_SETUP.md
[X] 5.2 Persistance des données de l'IA ✅ COMPLÉTÉ
notes : ✅ Implémenté via le système de Capabilities Forge (AIData, IAIData, AIDataProvider, AIDataCapabilityInit). Les données sauvegardées incluent : objectif actuel, expérience, compétences, lieux connus, mémoire (clé-valeur), et configuration des goals. Sauvegarde automatique dans NBT avec support de sérialisation JSON pour les données complexes.
libs : Gson (déjà présent dans le projet) utilisé pour la sérialisation. SQLite et Jackson disponibles en option pour des besoins avancés.
[X] 5.3 Interface utilisateur (GUI) pour l'IA ✅ COMPLÉTÉ
notes : ✅ Implémenté avec AIConfigScreen pour la configuration des goals, et packets réseau (OpenAIConfigS2CPacket, UpdateAIConfigC2SPacket) pour la synchronisation client-serveur. L'interface permet d'activer/désactiver les goals (Patrol, Follow Player, Collect Resources) avec un retour visuel en temps réel.
libs : Système natif Minecraft/Forge utilisé. Elementa ou MDXLib peuvent être ajoutées en option pour des interfaces plus sophistiquées.
[ ] 5.4 Modèle 3D et animations de l’IA
notes : Il s’agit de doter l’IA d’une représentation visuelle avancée, avec un modèle 3D personnalisé et possiblement des animations. Avec Forge, on peut définir un modèle d’entité custom (par ex. créé sous Blockbench) et l’intégrer via un EntityRenderer et une classe de Model dédiés. Les animations peuvent être gérées soit en codant manuellement le mouvement des parties du modèle à chaque tick (en modifiant les rotations/positions des bones dans la méthode de rendu ou via un AnimationState), soit en utilisant un moteur d’animation tiers. Forge permet également d’afficher des éléments 3D additionnels dans le monde (lignes, formes…) via l’API de rendu bas-niveau (par ex. en utilisant Tesselator et BufferBuilder dans un event de type RenderLevelLastEvent) – on pourrait s’en servir pour visualiser le chemin calculé par l’IA ou son champ de vision sous forme de surbrillance. En somme, on exploite le pipeline de rendu de Minecraft (Blaze3D) pour dessiner tout élément 3D personnalisé utile, qu’il s’agisse du modèle même de l’IA ou de repères visuels aidant à comprendre son comportement.
libs : La bibliothèque GeckoLib est particulièrement utile pour gérer des modèles et des animations complexes : elle permet d’importer des animations squelettiques (format Bedrock/FBX) et de les jouer facilement sur les entités du mod, sans avoir à tout programmer manuellement. Pour les calculs géométriques ou matriciels, on peut également s’appuyer sur JOML (Java OpenGL Math Library), qui fournit des outils mathématiques efficaces pour manipuler vecteurs et matrices lors du rendu 3D.
[ ] 5.5 Interactions de l’IA avec l’environnement (minage, combat…)
notes : Pour que l’IA puisse agir concrètement sur le monde (miner des blocs, attaquer des monstres, utiliser des objets), il faut s’appuyer sur les mêmes mécanismes que ceux utilisés par les joueurs ou les entités vanilla. Par exemple, pour faire miner un bloc à l’IA, on peut simuler l’action d’un joueur en utilisant un FakePlayer (joueur virtuel fourni par Forge) qui exécute l’action de casse du bloc sur le serveur, ce qui respectera les règles du jeu (prise en compte de l’outil en main, du temps de minage et génération des drops, ainsi que les éventuels événements comme BlockEvent.BreakEvent). On peut aussi implémenter cela en appelant directement des méthodes serveur comme Level.destroyBlock après avoir positionné l’entité correctement, puis en gérant l’ajout de l’Item résultant dans l’inventaire de l’IA. De même pour le combat, on peut équiper l’entité IA d’une arme (un ItemStack épée) et lui assigner un but d’attaque (MeleeAttackGoal ou équivalent custom) afin qu’elle poursuie et frappe les cibles comme le ferait une créature hostile classique. Tout repose sur l’utilisation des API Forge/MC (events d’attaque, utilisation d’ItemUsageContext, etc.) pour faire interagir l’IA avec l’environnement de manière crédible et dans le respect des règles du jeu.
libs : On peut s’inspirer de Baritone (mod d’automatisation open-source) pour la logique de certaines actions complexes, car il inclut des routines pour miner ou construire automatiquement en calculant les actions nécessaires. Aucune autre bibliothèque spécifique n’est requise ici, car Forge fournit déjà les outils pour simuler des actions de jeu (via FakePlayer, events, etc.), mais réutiliser des algorithmes éprouvés d’automatisation peut faire gagner du temps.
[ ] 5.6 Optimisation et multithreading des calculs d’IA
notes : Les calculs liés à l’IA (notamment le pathfinding ou les prises de décision complexes) peuvent être coûteux en ressources, il est donc important de les optimiser et de les déporter hors du thread principal du jeu quand c’est possible. Techniquement, on peut créer un thread dédié ou utiliser un Executor (pool de threads) pour effectuer les calculs intensifs en parallèle, afin de ne pas bloquer le tick serveur. Il faut alors veiller à la sûreté d’accès concurrents : l’accès au monde de Minecraft n’est pas thread-safe, on évitera donc de modifier ou même de lire des données du monde depuis un thread secondaire sans précaution. La bonne pratique est de copier les données nécessaires (par ex. une liste de positions cibles ou l’état pertinent de l’IA) pour le calcul en arrière-plan, puis de planifier l’application du résultat sur le thread principal du jeu (par ex. via ServerLevel.execute côté serveur ou en utilisant la queue d’actions côté client avec Minecraft.getInstance().tell/enqueue). Parallèlement, on optimisera les algorithmes eux-mêmes : limiter la fréquence des recalculs (ex. ne pas recalculer un chemin tous les tick inutilement), utiliser des caches (mémoriser les derniers résultats valides), et choisir des structures de données efficaces pour manipuler de potentiels grands volumes (par exemple des heuristiques pour réduire le nombre de nœuds explorés en pathfinding). L’objectif est que l’IA soit réactive sans pour autant saturer le thread de jeu ni provoquer de ralentissements perceptibles.
libs : Des collections optimisées comme celles de fastutil (qui propose des structures de données basées sur des types primitifs plus performantes que les collections Java standard) peuvent être utiles pour gérer des listes ou graphes de grande taille efficacement. Par ailleurs, on peut s’appuyer sur les utilitaires de concurrence du JDK (package java.util.concurrent) pour gérer proprement les threads et tâches asynchrones, sans nécessiter de bibliothèque tierce supplémentaire.
[ ] 5.7 Support multijoueur et synchronisation réseau
notes : En environnement multijoueur, il faut s’assurer que l’IA fonctionne correctement côté serveur et que toutes les informations nécessaires soient synchronisées avec les clients. Concrètement, la logique de l’IA (décisions, calculs de chemin, interactions) devrait s’exécuter principalement sur le serveur, qui fait autorité sur le gameplay. Les clients recevront quant à eux les mises à jour habituelles de l’entité (position, animations…) via le moteur réseau de Minecraft. Si l’IA possède des états spécifiques à communiquer (par ex. une humeur, un objectif en cours) ou si l’on a besoin d’éléments visuels côté client, on enverra des packets personnalisés via l’API de réseau de Forge pour informer les clients de ces changements. Pour cela, on peut définir un canal réseau custom avec NetworkRegistry.newSimpleChannel, puis créer des messages (données sérialisées) et utiliser SimpleChannel.send(PacketDistributor.X, message) pour émettre vers tous les joueurs ou un joueur ciblé. Il faudra également veiller à n’appeler du code client (rendu, UI) que côté client et du code serveur (IA logic) que côté serveur, en utilisant par exemple des checks level.isClientSide ou les annotations de dist @OnlyIn(Dist.CLIENT) quand nécessaire. En résumé, le support multi implique une bonne séparation client/serveur et l’utilisation du système de synchronisation fourni par Forge pour que l’IA se comporte correctement pour tous les joueurs en jeu.
libs : Aucune bibliothèque externe particulière n’est nécessaire ici, car l’API réseau de Forge (basée sur Netty) fournit tout le nécessaire pour synchroniser les données de l’IA en multijoueur. On utilisera simplement les outils Forge et Minecraft (Brigadier pour déclarer d’éventuelles commandes côté serveur, système de packets Forge) pour gérer cette communication réseau.
[ ] 5.8 Système de commandes et communication joueur-IA
notes : Permettre au joueur de contrôler ou de communiquer avec l’IA peut se faire via des commandes texte ou le chat en jeu. Par exemple, on peut implémenter une commande dédiée (comme /ia) en utilisant Brigadier dans l’événement de registre des commandes Forge, avec diverses sous-commandes pour donner des ordres à l’IA (ex. /ia suivre, /ia stop, /ia chercher <ressource>). Chaque commande invoquera alors côté serveur les méthodes appropriées pour modifier le comportement de l’IA (par exemple en activant/désactivant certains Goals ou en changeant son état interne). Parallèlement, on peut écouter les messages du chat (ServerChatEvent) pour détecter si le joueur s’adresse à l’IA via une phrase clé (par ex. tout message commençant par le nom de l’IA), puis interpréter le texte et le traduire en action correspondante. Techniquement, cela nécessite de parser le message – pour des commandes formatées c’est simple grâce à Brigadier, pour du langage naturel cela peut impliquer un traitement plus complexe ou l’appel à un service d’IA externe. Dans un premier temps, des commandes strictes sont plus faciles à gérer de manière robuste. Enfin, le jeu peut fournir un retour au joueur via le chat ou l’UI (par ex. en envoyant un message avec player.sendSystemMessage pour confirmer “L’IA vous suit.”). Ce système repose donc sur l’infrastructure de commandes et d’événements fournie par Forge, en la reliant aux routines de l’IA du mod.
libs : Le framework de commande Brigadier (inclus nativement) suffit pour gérer des commandes structurées et leurs arguments de manière fiable. Si l’on envisageait d’analyser du langage naturel, on pourrait regarder du côté de bibliothèques NLP en Java (telles que Stanford CoreNLP ou OpenNLP) pour détecter l’intention dans une phrase, mais cela ajoute de la complexité et dépasse le cadre d’une intégration “pure Forge”.
[ ] 5.9 Système d'économie et de réputation du joueur
notes : Le joueur doit également disposer de mécanismes similaires aux PNJ pour enrichir l'interaction avec le monde et l'IA. Concrètement, il faut implémenter un système d'argent (devise in-game) permettant au joueur d'acheter/vendre des services ou objets auprès des villageois IA, ainsi qu'un système de réputation qui évolue selon les actions du joueur. Pour l'argent, on peut utiliser une Capability attachée au joueur (via ICapabilityProvider) stockant son solde, qui sera sauvegardé automatiquement dans les données du monde. Pour la réputation, on peut créer une structure de données (ex. Map<UUID, ReputationData>) associant chaque entité villageoise à un score de réputation vis-à-vis du joueur, stocké de manière similaire via Capability ou dans le CompoundTag du joueur. Les actions du joueur (insulter, frapper, voler, aider, commercer équitablement) doivent déclencher des événements (par ex. LivingHurtEvent, PlayerInteractEvent, ou des événements custom du mod) qui mettent à jour ces scores de réputation. Techniquement, chaque interaction négative (insulte détectée via analyse du texte du chat, attaque d'un villageois, vol d'objets) diminue la réputation, tandis que les interactions positives (quêtes accomplies, commerce, dons) l'augmentent. Le système de réputation peut ensuite influencer le comportement de l'IA : un villageois peut refuser de commercer, appeler des gardes, ou au contraire offrir des réductions et missions spéciales si la réputation est élevée. En résumé, on s'appuie sur les Capabilities Forge pour stocker l'état économique et social du joueur, et on utilise le système d'événements pour capturer et réagir aux actions du joueur, créant ainsi une expérience cohérente où le joueur possède les mêmes paramètres (argent, réputation, objectifs potentiels) que les entités IA qu'il côtoie.
libs : Aucune bibliothèque externe spécifique n'est requise pour l'économie et la réputation de base, car Forge fournit tout le nécessaire (Capabilities, événements, NBT). Si l'on souhaite analyser le langage naturel pour détecter des insultes dans le chat, on pourrait intégrer une bibliothèque NLP simple ou une liste de mots-clés. Pour un système économique plus complexe (transactions, marché dynamique), on peut s'inspirer de mods existants comme VillagerTrades ou utiliser des structures de données optimisées (fastutil) pour gérer efficacement les relations entre de nombreux villageois et le joueur.
[ ] 5.10 Tests finaux, débogage et polish du mod
notes : Avant de conclure le développement, il est important de tester en profondeur toutes les fonctionnalités de l'IA afin de corriger les derniers bugs et d'ajuster les détails. Concrètement, cela signifie observer le comportement de l’IA dans divers scénarios en jeu réel (monde solo, serveur avec plusieurs joueurs, différentes configurations) : vérification que le pathfinding réagit bien sur tout type de terrain, que l’IA interagit correctement avec les blocs et entités (sans comportement aberrant), que l’interface utilisateur transmet bien les commandes, etc. Durant ces tests, on peut utiliser les outils de debug de Minecraft (par ex. F3+B pour voir les hitboxes et cibles des entités, ou des messages de log dans la console) pour comprendre ce que “pense” l’IA et identifier d’éventuels problèmes de logique. Une fois les bugs corrigés, on procède au polish final : ajustement des paramètres (vitesse de déplacement de l’IA, délais dans ses actions pour paraître naturelle, portées de détection), amélioration des performances si nécessaire, et nettoyage du code. Cela inclut aussi la rédaction d’une documentation de base (par ex. un README ou un guide rapide expliquant comment utiliser l’IA dans le jeu) et la préparation de la sortie (versioning, changelog, packaging du mod pour sa publication). L’objectif est de livrer un mod stable, optimisé et compréhensible, prêt à être utilisé par les joueurs ou amélioré par d’autres développeurs.
