Phase 5 : Fonctionnalités avancées de l’IA
[ ] 5.0 Architecture du système d’IA modulable
notes : On peut structurer le comportement de l’IA en utilisant le système d’objectifs (Goals) fourni par Minecraft Forge. Chaque comportement (patrouiller, suivre un joueur, collecter des ressources...) peut être implémenté comme une classe de Goal attachée à l’entité IA et gérée par son goalSelector. Techniquement, cela consiste à définir des conditions de déclenchement et des actions pour chaque objectif, Forge orchestrant leur exécution en fonction de leur priorité. Alternativement, pour une IA plus sophistiquée, on peut concevoir un automate d’états finis ou un arbre de comportement (Behavior Tree) qui détermine l'action de l’IA en fonction de son état et de son environnement, en s’appuyant sur des tick events ou un scheduler pour évaluer régulièrement la situation de l’IA.
libs : Une bibliothèque comme gdx-ai (libGDX AI) offre des implémentations prêtes de machines à états et de behavior trees pouvant être adaptées, ce qui peut accélérer le développement d’un comportement complexe.
[ ] 5.1 Pathfinding avancé pour l’IA
notes : Minecraft intègre déjà un pathfinding A basique via des classes comme PathNavigator et NodeEvaluator pour les entités. On peut étendre ou ajuster ces composants (par exemple en créant un PathNavigator personnalisé ou en modifiant les critères de NodeEvaluator) afin d’améliorer la navigation de l’IA (meilleure prise en compte des obstacles, du terrain dangereux, etc.). Techniquement, il est aussi envisageable de calculer manuellement des chemins optimisés (par exemple avec l’algorithme A) en explorant la grille des blocs du monde, puis de faire suivre ce chemin à l’entité en mettant à jour sa position cible étape par étape. Forge permet d’accéder aux données du monde (blocs, collisions) nécessaires à un tel algorithme, et on peut éventuellement pré-calculer ou mettre en cache certains parcours pour plus d’efficacité.
libs : On peut utiliser une bibliothèque de pathfinding telle que gdx-ai (qui fournit notamment A et un pathfinding hiérarchique) ou s’inspirer de projets open-source comme Baritone* (bot de navigation Minecraft) pour implémenter un pathfinding plus performant et complet.
[ ] 5.2 Persistance des données de l’IA
notes : Il faut conserver les données importantes de l’IA entre les sessions de jeu (par exemple son expérience acquise, sa configuration ou des points d’intérêt mémorisés). Pour ce faire, Forge propose le système de Capabilities qui permet d’attacher des données persistantes à des entités ou au joueur, automatiquement sauvegardées dans les fichiers du monde. Par exemple, on peut créer une capability IAData pour stocker l’état interne de l’IA et utiliser un ICapabilityProvider sur l’entité correspondante. Alternativement ou en complément, on peut écrire les données dans le CompoundTag (NBT) de l’entité en surchargeant ses méthodes de sauvegarde (saveAdditional / load), ou encore utiliser un fichier externe (JSON, etc.) dans le dossier du monde pour y stocker des informations globales. L’idée est d’exploiter les API Forge de persistance pour garantir que l’IA retrouve son état et ses apprentissages après un redémarrage du jeu.
libs : Des bibliothèques comme Gson ou Jackson peuvent aider à sérialiser/désérialiser des données en JSON pour un stockage sur disque plus lisible. Sinon, un moteur embarqué comme SQLite (via le driver JDBC) peut être utilisé si l’on souhaite stocker et requêter des données complexes de l’IA de manière structurée.
[ ] 5.3 Interface utilisateur (GUI) pour l’IA
notes : Il peut être nécessaire de fournir une interface graphique en jeu pour configurer l’IA ou interagir avec elle (par exemple un panneau de contrôle ou une fenêtre de dialogue). Techniquement, on crée un nouvel écran (Screen) personnalisé côté client en utilisant l’API GUI de Forge/Minecraft, avec les boutons, textes et champs requis. On peut ouvrir cet écran via un événement (commande / dédiée, clic sur un objet spécial, etc.) en appelant NetworkHooks.openScreen depuis le serveur pour synchroniser une interface de type Container, ou directement via Minecraft.getInstance().setScreen si l’UI n’a pas besoin d’interactions serveur. Les échanges entre l’UI et l’IA se font ensuite par paquets réseau (envoi au serveur des réglages choisis par le joueur, puis mise à jour de l’IA en conséquence). En résumé, on s’appuie sur les classes de GUI de Minecraft (par ex. GuiComponent, AbstractContainerScreen pour un inventaire custom, ou simplement Screen pour une interface libre) afin de construire une UI interactive propre au mod.
libs : Pour accélérer le développement, on peut exploiter des bibliothèques GUI dédiées aux mods Minecraft. Par exemple, Elementa (la librairie d’interface du mod Essential) facilite la création d’interfaces de manière déclarative et responsive, ou encore MDXLib (si adaptée à la version 1.21) qui offre un framework moderne pour les GUI, avec widgets et thèmes, afin de concevoir plus rapidement une interface utilisateur aboutie.
[ ] 5.4 Modèle 3D et animations de l’IA
notes : Il s’agit de doter l’IA d’une représentation visuelle avancée, avec un modèle 3D personnalisé et possiblement des animations. Avec Forge, on peut définir un modèle d’entité custom (par ex. créé sous Blockbench) et l’intégrer via un EntityRenderer et une classe de Model dédiés. Les animations peuvent être gérées soit en codant manuellement le mouvement des parties du modèle à chaque tick (en modifiant les rotations/positions des bones dans la méthode de rendu ou via un AnimationState), soit en utilisant un moteur d’animation tiers. Forge permet également d’afficher des éléments 3D additionnels dans le monde (lignes, formes…) via l’API de rendu bas-niveau (par ex. en utilisant Tesselator et BufferBuilder dans un event de type RenderLevelLastEvent) – on pourrait s’en servir pour visualiser le chemin calculé par l’IA ou son champ de vision sous forme de surbrillance. En somme, on exploite le pipeline de rendu de Minecraft (Blaze3D) pour dessiner tout élément 3D personnalisé utile, qu’il s’agisse du modèle même de l’IA ou de repères visuels aidant à comprendre son comportement.
libs : La bibliothèque GeckoLib est particulièrement utile pour gérer des modèles et des animations complexes : elle permet d’importer des animations squelettiques (format Bedrock/FBX) et de les jouer facilement sur les entités du mod, sans avoir à tout programmer manuellement. Pour les calculs géométriques ou matriciels, on peut également s’appuyer sur JOML (Java OpenGL Math Library), qui fournit des outils mathématiques efficaces pour manipuler vecteurs et matrices lors du rendu 3D.
[ ] 5.5 Interactions de l’IA avec l’environnement (minage, combat…)
notes : Pour que l’IA puisse agir concrètement sur le monde (miner des blocs, attaquer des monstres, utiliser des objets), il faut s’appuyer sur les mêmes mécanismes que ceux utilisés par les joueurs ou les entités vanilla. Par exemple, pour faire miner un bloc à l’IA, on peut simuler l’action d’un joueur en utilisant un FakePlayer (joueur virtuel fourni par Forge) qui exécute l’action de casse du bloc sur le serveur, ce qui respectera les règles du jeu (prise en compte de l’outil en main, du temps de minage et génération des drops, ainsi que les éventuels événements comme BlockEvent.BreakEvent). On peut aussi implémenter cela en appelant directement des méthodes serveur comme Level.destroyBlock après avoir positionné l’entité correctement, puis en gérant l’ajout de l’Item résultant dans l’inventaire de l’IA. De même pour le combat, on peut équiper l’entité IA d’une arme (un ItemStack épée) et lui assigner un but d’attaque (MeleeAttackGoal ou équivalent custom) afin qu’elle poursuie et frappe les cibles comme le ferait une créature hostile classique. Tout repose sur l’utilisation des API Forge/MC (events d’attaque, utilisation d’ItemUsageContext, etc.) pour faire interagir l’IA avec l’environnement de manière crédible et dans le respect des règles du jeu.
libs : On peut s’inspirer de Baritone (mod d’automatisation open-source) pour la logique de certaines actions complexes, car il inclut des routines pour miner ou construire automatiquement en calculant les actions nécessaires. Aucune autre bibliothèque spécifique n’est requise ici, car Forge fournit déjà les outils pour simuler des actions de jeu (via FakePlayer, events, etc.), mais réutiliser des algorithmes éprouvés d’automatisation peut faire gagner du temps.
[ ] 5.6 Optimisation et multithreading des calculs d’IA
notes : Les calculs liés à l’IA (notamment le pathfinding ou les prises de décision complexes) peuvent être coûteux en ressources, il est donc important de les optimiser et de les déporter hors du thread principal du jeu quand c’est possible. Techniquement, on peut créer un thread dédié ou utiliser un Executor (pool de threads) pour effectuer les calculs intensifs en parallèle, afin de ne pas bloquer le tick serveur. Il faut alors veiller à la sûreté d’accès concurrents : l’accès au monde de Minecraft n’est pas thread-safe, on évitera donc de modifier ou même de lire des données du monde depuis un thread secondaire sans précaution. La bonne pratique est de copier les données nécessaires (par ex. une liste de positions cibles ou l’état pertinent de l’IA) pour le calcul en arrière-plan, puis de planifier l’application du résultat sur le thread principal du jeu (par ex. via ServerLevel.execute côté serveur ou en utilisant la queue d’actions côté client avec Minecraft.getInstance().tell/enqueue). Parallèlement, on optimisera les algorithmes eux-mêmes : limiter la fréquence des recalculs (ex. ne pas recalculer un chemin tous les tick inutilement), utiliser des caches (mémoriser les derniers résultats valides), et choisir des structures de données efficaces pour manipuler de potentiels grands volumes (par exemple des heuristiques pour réduire le nombre de nœuds explorés en pathfinding). L’objectif est que l’IA soit réactive sans pour autant saturer le thread de jeu ni provoquer de ralentissements perceptibles.
libs : Des collections optimisées comme celles de fastutil (qui propose des structures de données basées sur des types primitifs plus performantes que les collections Java standard) peuvent être utiles pour gérer des listes ou graphes de grande taille efficacement. Par ailleurs, on peut s’appuyer sur les utilitaires de concurrence du JDK (package java.util.concurrent) pour gérer proprement les threads et tâches asynchrones, sans nécessiter de bibliothèque tierce supplémentaire.
[ ] 5.7 Support multijoueur et synchronisation réseau
notes : En environnement multijoueur, il faut s’assurer que l’IA fonctionne correctement côté serveur et que toutes les informations nécessaires soient synchronisées avec les clients. Concrètement, la logique de l’IA (décisions, calculs de chemin, interactions) devrait s’exécuter principalement sur le serveur, qui fait autorité sur le gameplay. Les clients recevront quant à eux les mises à jour habituelles de l’entité (position, animations…) via le moteur réseau de Minecraft. Si l’IA possède des états spécifiques à communiquer (par ex. une humeur, un objectif en cours) ou si l’on a besoin d’éléments visuels côté client, on enverra des packets personnalisés via l’API de réseau de Forge pour informer les clients de ces changements. Pour cela, on peut définir un canal réseau custom avec NetworkRegistry.newSimpleChannel, puis créer des messages (données sérialisées) et utiliser SimpleChannel.send(PacketDistributor.X, message) pour émettre vers tous les joueurs ou un joueur ciblé. Il faudra également veiller à n’appeler du code client (rendu, UI) que côté client et du code serveur (IA logic) que côté serveur, en utilisant par exemple des checks level.isClientSide ou les annotations de dist @OnlyIn(Dist.CLIENT) quand nécessaire. En résumé, le support multi implique une bonne séparation client/serveur et l’utilisation du système de synchronisation fourni par Forge pour que l’IA se comporte correctement pour tous les joueurs en jeu.
libs : Aucune bibliothèque externe particulière n’est nécessaire ici, car l’API réseau de Forge (basée sur Netty) fournit tout le nécessaire pour synchroniser les données de l’IA en multijoueur. On utilisera simplement les outils Forge et Minecraft (Brigadier pour déclarer d’éventuelles commandes côté serveur, système de packets Forge) pour gérer cette communication réseau.
[ ] 5.8 Système de commandes et communication joueur-IA
notes : Permettre au joueur de contrôler ou de communiquer avec l’IA peut se faire via des commandes texte ou le chat en jeu. Par exemple, on peut implémenter une commande dédiée (comme /ia) en utilisant Brigadier dans l’événement de registre des commandes Forge, avec diverses sous-commandes pour donner des ordres à l’IA (ex. /ia suivre, /ia stop, /ia chercher <ressource>). Chaque commande invoquera alors côté serveur les méthodes appropriées pour modifier le comportement de l’IA (par exemple en activant/désactivant certains Goals ou en changeant son état interne). Parallèlement, on peut écouter les messages du chat (ServerChatEvent) pour détecter si le joueur s’adresse à l’IA via une phrase clé (par ex. tout message commençant par le nom de l’IA), puis interpréter le texte et le traduire en action correspondante. Techniquement, cela nécessite de parser le message – pour des commandes formatées c’est simple grâce à Brigadier, pour du langage naturel cela peut impliquer un traitement plus complexe ou l’appel à un service d’IA externe. Dans un premier temps, des commandes strictes sont plus faciles à gérer de manière robuste. Enfin, le jeu peut fournir un retour au joueur via le chat ou l’UI (par ex. en envoyant un message avec player.sendSystemMessage pour confirmer “L’IA vous suit.”). Ce système repose donc sur l’infrastructure de commandes et d’événements fournie par Forge, en la reliant aux routines de l’IA du mod.
libs : Le framework de commande Brigadier (inclus nativement) suffit pour gérer des commandes structurées et leurs arguments de manière fiable. Si l’on envisageait d’analyser du langage naturel, on pourrait regarder du côté de bibliothèques NLP en Java (telles que Stanford CoreNLP ou OpenNLP) pour détecter l’intention dans une phrase, mais cela ajoute de la complexité et dépasse le cadre d’une intégration “pure Forge”.
[ ] 5.9 Tests finaux, débogage et polish du mod
notes : Avant de conclure le développement, il est important de tester en profondeur toutes les fonctionnalités de l’IA afin de corriger les derniers bugs et d’ajuster les détails. Concrètement, cela signifie observer le comportement de l’IA dans divers scénarios en jeu réel (monde solo, serveur avec plusieurs joueurs, différentes configurations) : vérification que le pathfinding réagit bien sur tout type de terrain, que l’IA interagit correctement avec les blocs et entités (sans comportement aberrant), que l’interface utilisateur transmet bien les commandes, etc. Durant ces tests, on peut utiliser les outils de debug de Minecraft (par ex. F3+B pour voir les hitboxes et cibles des entités, ou des messages de log dans la console) pour comprendre ce que “pense” l’IA et identifier d’éventuels problèmes de logique. Une fois les bugs corrigés, on procède au polish final : ajustement des paramètres (vitesse de déplacement de l’IA, délais dans ses actions pour paraître naturelle, portées de détection), amélioration des performances si nécessaire, et nettoyage du code. Cela inclut aussi la rédaction d’une documentation de base (par ex. un README ou un guide rapide expliquant comment utiliser l’IA dans le jeu) et la préparation de la sortie (versioning, changelog, packaging du mod pour sa publication). L’objectif est de livrer un mod stable, optimisé et compréhensible, prêt à être utilisé par les joueurs ou amélioré par d’autres développeurs.
